% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/baseArgsFn.R
\name{baseArgsFn}
\alias{baseArgsFn}
\title{Provide the \code{baseArgs} for analyzing a data set}
\usage{
baseArgsFn(e, t, r, tStar, design, riskGroup, rSummary, bootstrap,
  confidenceLevel = 0.95, multicore = FALSE, verbose = FALSE)
}
\arguments{
\item{e}{A vector of events for each subject in the dataset.
The event for one subject can either be a 
\code{0} (censored), \code{1} (disease) or \code{2} (death from other causes).}

\item{t}{A vector of times until event for each subject in the dataset.
This is the time that the event \code{e} occurred.  
This time must fall in the interval \code{[0, tStar)}, where \code{tStar} is 
the duration of the study.}

\item{r}{A vector of risk values for each subject in the dataset.
This is the probability of disease, as predicted by a risk model.  
The goal of the \code{rmap} package is to assess the validity of and
calibration of this model.}

\item{tStar}{A positive number equal to the duration of the the study.}

\item{design}{One of the following choices
\itemize{
\item{\code{"randomSample"}: }{Using \code{design = "randomSample"}
  signals to \code{rmap} that you obtained your data using a
  random sample.
}
\item{\code{list(c = c, N_two_stage = N_two_stage)}: }{If your
  design is a two-stage sample, name your two-stage sampling
  categories with capital letters beginning with \code{"A"},
  \code{"B"}, etc., let \code{c} be the vector of each subjects's
  sampling category, and \code{N_two_stage} be a named vector
  counting the number
  of subjects from the first stage that fell into each category.
  (For example, if the two categories were \code{"A"} and \code{"B"}, 
  and there were \code{13} in the first stage who were categorized
  to \code{"A"} and \code{42} to \code{"B"}, then define
  \code{N_two_stage = c(A = 13, B = 42)}; you would of course have
  much larger numbers than \code{13} and \code{42}).
  Specify \code{design = list(c = c, N_two_stage = N_two_stage)}.
}
\item{\code{list(c = c, target_category = target_category)}: }{ If your
  cohort sample does not match your target population and you have 
  a sample from your target population and both samples contain 
  relevant categories, label the categories beginning with \code{"A"},
  \code{"B"}, etc, and let \code{c} be the vector of cohort subjects'
  categories and \code{target_category} be the vector of target
  subjects' categories, and specify 
  \code{design = list(c = c, target_category = target_category)}.
}
}}

\item{riskGroup}{Describes the way you want the subjects to be divided
into risk groups. One of the following named lists:
\itemize{
\item{\code{list(K = k)}: }{You can manually assign risk groups using 
an integer vector \code{k} containing risk group assignments for each 
subject in the dataset.  Define \code{K} to be the total number of 
risk groups.  Then your vector \code{k} is a risk group assignment  
in \code{\{1, ..., K\}} for each subject in the dataset.  
Subjects with risk group assignment \code{= 1} should have the smallest 
assigned risks (\code{r}), and subjects with the risk group assignment 
\code{= K} should have the highest assigned risks.
}
\item{\code{list(K = K)}: }{Define \code{K} to be a positive integer
and let \code{rmap} divide your sample into \code{K} quantiles.  For 
example, if \code{K = 4}, your risk groups will consist of \code{4}
quartiles, the first group, \code{k = 1}, containing the subjects
with the smallest risks \code{r}, the fourth group, \code{k = 4}, 
containing the subjects with the largest risks.
}
\item{\code{list(cutoffs = cutoffs)}: }{Risk groups can also be 
assigned to each subject in the dataset based on risk "cutoffs". 
If you wished to create three risk groups, say all subjects having 
an assigned risk between 0 and 0.2 to be in risk group 1, 
all subjects with assigned risk between 0.2 and 0.5 to be in risk 
group 2, and all subjects with assigned risk between 0.5 and 1 
to be in risk group 3, define \code{cutoffs = c(0, 0.2, 0.5, 1)}.
}
\item{\code{list(epsilon = epsilon)}: }{The previous three 
ways that the riskGroup argument was specified were ways to 
group subjects for a grouped analysis. We can also validate 
risk models using an ungrouped analysis. The calculations 
require a small positive number, epsilon, specifying
the  kernel neighborhoods used to calculate observed risk
at each distinct assigned risk. Asymptotic theory suggests
good behavior for \code{epsilon = N^(-1/3)}.
}
}}

\item{rSummary}{A summary statistic for summarizing the 
assigned risks for all subjects in a risk group.  The \code{rSummary} 
can be calculated by the program or you may wish to provide one. 
If you would like an ungrouped analysis 
(\code{riskGroup = list(epsilon = epsilon)}), then 
\code{rmap} will automatically use "mean" to summarize the 
risk in each epsilon neighborhood.
There are four options in specifying the rSummary: 
\itemize{
\item{\code{"mean"}: } {Summarize each risk group with
code{mean(r)} over all values of \code{r} in that risk group.
}
\item{\code{"median"}: } {Summarize each risk group with
code{median(r)} over all values of \code{r} in that risk group.
}
\item{\code{"midpoint"}: } {If 
\code{riskGroup = list(cutoffs = c(0, 0.2, 0.5, 1))}, then the 
\code{rSummary} would be assigned \code{c(0.1, 0.35, 0.75)}.
}
\item{A user supplied summary vector } {You may manually specify
your own values for \code{rSummary}.
To use this option, define \code{rSummary} to be a 
numeric vector of length \code{K} specifying your summary statistic
for each risk group.
}
}}

\item{bootstrap}{Either a single integer number, 
describing the number of bootstraps or \code{FALSE} 
to turn off bootstrapping.}

\item{confidenceLevel}{A positive number less than \code{1}, 
defaulted to \code{0.95}, specifying the confidence levels of the
confidence intervals inside \code{rmap}.}

\item{multicore}{Currently not used.
A logical value. If multicore = TRUE and
(\code{riskGroup = list(epsilon = epsilon)}) and bootstrap 
is not set to FALSE), multiple processors are used to 
compute the bootstraps.}

\item{verbose}{Currently not used.
If verbose = TRUE and
(\code{riskGroup = list(epsilon = epsilon)}) and bootstrap 
is not set to FALSE), progress of the calculation will be 
output during the calculations of the nearest neighbor and 
the bootstrap nearest neighbor.  Such output is useful for 
checking the progress of these calculations which can require 
a long time depending on the number of observations and the number
of distinct assigned risks.}
}
\value{
A list containing
\itemize{
\item{\code{c}: }{Equal to the input \code{c} if two-stage sampling
  or weighted sampling, and equal to a vector of all \code{"A"}s if
  random sampling. A character vector of length \code{N}. 
}
\item{\code{category_weights}: }{Equal to \code{NULL} 
  for random sampling and two-stage sampling. For weighted sampling, 
  a named vector (analogous to 
  \code{N_two_stage / n_two_stage}) with one element for each
  sampling category counting the number of subjects in the 
  \code{target_category / c}. (A better name for \code{c}
  would be \code{cohort_category} when in the universe of 
  weighted sampling.) Not required outside of \code{rmap}.
}
\item{\code{confidence_level}: }{Equal to the input 
  \code{confidenceLevel}.
}
\item{\code{e}: }{Equal to the input \code{e}.
}
\item{\code{epsilon}: }{Equal to the input \code{epsilon} 
if \code{riskGroup = list(epsilon = epsilon)}.  Otherwise equal to \code{NA}
}
\item{\code{K}: }{A positive integer equal to the number
of risk groups.  If \code{ungrouped = TRUE}, this is equal to \code{1}.
}
\item{\code{k}: }{A vector of length \code{N} indicating the
risk group membership of each subject.  
If \code{ungrouped = TRUE}, this is a vector of all \code{1}'s.
If \code{ungrouped = FALSE}, this vector was either specified
by the user (\code{riskGroup = list{k = k}}) or calculated
by \code{baseArgsFn}. 
Each element in this vector is in \code{\{1, ..., K\}}.
}
\item{\code{multicore}: }{A logical value equal to the input 
\code{multicore}
}
\item{\code{nBootstraps}: }{Equal to \code{N_bootstraps}. Currently used just in baseArgsFn
}
\item{\code{N_bootstraps}: }{An integer describing the 
number of bootstraps, where \code{0} indicates no bootstraps.
}
\item{\code{N_two_stage}: }{A named integer vector with one element
  for each sampling category counting the number of subjects in the
  first stage of a two-stage sampling design.  For
  random sampling, (\code{design = "randomSample"}), 
  \code{N_two_stage = N}. For weighted design
  (\code{design = list(c = c, target_category = target_category)}),
  this variable is not used and
  \code{N_two_stage = NULL}.
}
\item{\code{n_two_stage}: }{A named integer vector with one element
  for each sampling category counting the number of subjects in the
  second stage of a two-stage sampling design.  For
  random sampling, (\code{design = "randomSample"}), 
  \code{N_two_stage = N}. For weighted design
  (\code{design = list(c = c, target_category = target_category)}),
  this variable is not used and
  \code{N_two_stage = NULL}.
}
\item{\code{N_nonzero_events}: }{An integer vector of 
  length \code{K} counting the number events in each
  risk group that occurred before \code{tStar}
  and were not censored.
}
\item{\code{r}: }{Equal to the input \code{r}.
}
\item{\code{rSummary}: }{If \code{ungrouped = FALSE}, 
\code{rSummary} is a vector of risk summaries, one for 
  each risk group.  This vector can be given by the 
  user or calculated by \code{baseArgsFn} using 
  method \code{"mean"}, \code{"median"}, or 
  \code{"midpoint"}.  If \code{ungrouped = TRUE}, 
  \code{rSummary} is the forced to be the mean of 
  the code{r} values in each epsilon 
  neighborhood.
}
\item{\code{sampling}: }{A string equal to one of
  \code{"randomSample"}, \code{"twoStage"},
  \code{"weighted"}
}
\item{\code{t}: }{Equal to the input \code{t}.
}
\item{\code{tStar}: }{Equal to the input \code{tStar}.
}
\item{\code{target_category}: }{If
  \code{sampling = "weighted"}, the same as
  \code{target_category} in the input
  \code{design = list(c = c, target_category = target_category)}.
  For \code{sampling = "randomSampling"} or
  \code{sampling = "twoStage"}, \code{target_category = NULL}.
}
\item{\code{ungrouped}: }{Equal to \code{TRUE} if
  \code{riskGroup = list(epsilon = epsilon)} was chosen.
}
\item{\code{verbose}: }{A logical equal to the input
  \code{verbose}.
}
\item{\code{weight}: }{A vector of length \code{N} equal
  to the weight to assign to each subject.  For 
  \code{sampling = "randomSampling"}, \code{weight = 1}.
  For \code{sampling = "twoStage"}, \code{weight} is equal to
  \code{aaa} in the formulas (\code{N_two_stage/n_two_stage}).
  For \code{sampling = "weighted"}, \code{weight} is determined by 
  \code{c} and \code{category_weights}.
}
}
}
\description{
This function translates arguments given by the user into a data structure 
that is used internally throughout the \code{rmap} package.
}
\examples{
################################################# randomSample grouped
options(digits = 3)
set.seed(1)
randomSample = df_randomSample(100)
xxx = randomSample
e = xxx$e
t = xxx$t
r = xxx$r
tStar = 10
design = "randomSample"
riskGroup = list(K = 2)
rSummary = "mean"
bootstrap = 20
baseArgs = baseArgsFn(e, t, r, tStar, design, riskGroup, rSummary, bootstrap)
baseArgs
################################################# randomSample grouped
options(digits = 3)
set.seed(1)
randomSample = df_randomSample(100)
xxx = randomSample
e = xxx$e
t = xxx$t
r = xxx$r
tStar = 10
design = "randomSample"
epsilon = nrow(xxx)^(-1/3)
riskGroup = list(epsilon = epsilon)
rSummary = "mean"
bootstrap = 20
baseArgs = baseArgsFn(e, t, r, tStar, design, riskGroup, rSummary, bootstrap)
baseArgs
################################################# twoStage grouped
set.seed(1)
twoStageSample = df_twoStage(200)
xxx = twoStageSample$d
e = xxx$e
t = xxx$t
r = xxx$r
N = twoStageSample$N
design = list(N_two_stage = N, c = xxx$c)
riskGroup = list(K = 2)
rSummary = "mean"
bootstrap = 100
baseArgs = baseArgsFn(e, t, r, tStar, design, riskGroup, rSummary, bootstrap)
baseArgs
################################################# twoStage ungrouped
set.seed(1)
twoStageSample = df_twoStage(200)
xxx = twoStageSample$d
e = xxx$e
t = xxx$t
r = xxx$r
N = twoStageSample$N
design = list(N_two_stage = N, c = xxx$c)
epsilon = nrow(xxx)^(-1/3)
riskGroup = list(epsilon = epsilon)
rSummary = "mean"
bootstrap = 100
baseArgs = baseArgsFn(e, t, r, tStar, design, riskGroup, rSummary, bootstrap)
baseArgs
################################################# weighted grouped
set.seed(1)
NNN = 200
N_bootstrap_reps = 100
cutoffs = c(0, 0.20, 1)
weighted_example = weighted_example_fn(NNN)
cohort_sampling_probability_dictionary = weighted_example$cohort_sampling_probability_dictionary
cohort_sample = weighted_example$cohort_sample
target_sample = weighted_example$target_sample
tStar = weighted_example$t_star
which_model = "r_B" 
cohort_category = cohort_sample$category
target_category = target_sample$category
r = cohort_sample[[which_model]]
e = cohort_sample$eee
t = cohort_sample$ttt
design = list(target_category = target_category, c = cohort_category)
riskGroup = list(cutoffs = cutoffs)
rSummary = "mean"
bootstrap = N_bootstrap_reps
baseArgs = baseArgsFn(e, t, r, tStar, design, riskGroup, rSummary, bootstrap) 
baseArgs
}
