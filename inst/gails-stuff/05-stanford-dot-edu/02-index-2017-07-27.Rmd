---
title: "rmap---v-0.02-03--2017-07-27 09:41:03 PDT"
author: ''
output:
  html_document:
    css: ~/Documents/headings.css
    fig_caption: yes
    highlight: default
    number_sections: yes
    theme: readable
    toc: yes
  pdf_document:
    highlight: tango
    number_sections: yes
    pandoc_args: --variable=geometry:margin=0.75in
    toc: yes
fontsize: 12pt

---
<A NAME="top"> </A>
```{r global_options, include=FALSE}
require(knitr)
opts_chunk$set(eval = TRUE, echo = TRUE, fig.height = 2.5, fig.width = 7, tidy=FALSE)
```

# Introduction {#introduction}

Personal predictive models use an individual's personal covariates to assign him/her a probability of developing a specific disease within a specified future time period `[0, t_star]` and before a prespecified competing risk.  Predictive models are often evaluated by comparing their assigned risks to outcome incidences among participants in a cohort study.  Performance of such models can be evaluated using two criteria: calibration and concordance. Model calibration (also called goodness-of-fit) measures how well the model-assigned risks agree
with persons' subsequent observed outcomes. `rmap` offers a grouped goodness-of-fit test and grouped and ungrouped attribute diagrams. Concordance (also called the area under the ROC curve) measures how well a model separates positive and negative outcomes.`rmap` offers estimation and confidence intervals for the concordance as well as ROC plots. `rmap` handles random samples, two-stage sample designs, and weighted sample designs.

Below is a very simple call to an `rmap` function on a simulated random sample. `rmap can estimate concordance, produce ROC plots, test for grouped goodness-of-fit, and produce grouped and ungrouped attribute diagrams.


```{r message = FALSE, echo = TRUE, fig.height = 5, fig.widht = 7}
library(rmap)
xxx = read.csv(file = "random_sample_example.csv", stringsAsFactors = FALSE)
e = xxx$e
t = xxx$t
r = xxx$r
t_star = 10
rmap_2 = rmap_random_sample_ungrouped_too(e, t, r, t_star)
the_message = paste("The package rmap in action",sep = "\n")
grid.arrange(textGrob(the_message),  rmap_2$grouped_risk_plot, 
             rmap_2$roc_plot, rmap_2$ungrouped_risk_plot,
             ncol = 2)
```

The following sections describe how to install `rmap`, the inputs you need`, how to interpret `rmap` outputs, and some examples.

[TOP](#top)

# Installing rmap {#installing-rmap}

If you have not yet installed R, download the latest version (at least 3.4.0) for your operating system at:

http://www.r-project.org

Run the R application. To install the rmap package, enter the following lines of code to the R prompt:

```
install.packages("devtools")
library(devtools)
install_github("gailg/rmap")
if("rmap" %in% rownames(installed.packages())){
  print("rmap installed successfully--you are good to go!")
} else {
  print("something went wrong--ask for help")
}
```
If your installation was successful, you should see the message

```
[1] "rmap installed successfully--you are good to go!"
```

[TOP](#top)


# Data preparation {#data-preparation}

You need a data set, containing, say $N$ people, and for the $n$-th person, you have the following data:

## `e`

The event for the subject. Record`e = 1` if the outcome of interest was observed to occur before `t_star` and before the competing event, `e = 2` if the competing risk, such as death from other causes,  was observed to occur before `t_star` and before the adverse outcome, and  `0` if censored before outcome and competing risk.  Acceptable values are `0, 1, 2`.

## `t`

The time until the event `e`.  Mathematically speaking, let `t_1` be time until outcome, `t_2` time until competing risk, `t_0` time until censoring . Then `t` is the minimum of `t_1`, `t_2`, `t_0`, and `e` records which of the events occurred first. Acceptable values are positive real numbers.

## `r`

The risk assigned by the personal predictive model. This is the probability of outcome occuring before the competing risk and before `t_star`. Acceptable values are (real numbers between `0` and `1`, including `0` and `1`).


## `category` (optional)

If your data were obtained by two-stage sampling, this is the two-stage category indicating which two-stage category the person fell into. (See `N_first_stage` below.)  If your data are a cohort sample whose relevant covariates do not match your target population, and you would like to weight your cohort samples based on covariate information from a target population, `category` records which covariate category the (cohort) person fell into. (See `N_target` below.)


# Reading in data {#reading-in-data}

If your data is an excel file with columns `e`, `t`, `r`, and possibly `category`, save it as a CSV (comma separated value) file into your working directory. For practice you can download my excel file here, put it into your working directory, and try out the following commands.


```{r eval = TRUE}
xxx = read.csv(file = "random_sample_example.csv", stringsAsFactors = FALSE)
head(xxx)
```
If you got the same results I get above, you are in business.  

# Other data you may need

## `N_first_stage`

If you obtained your data using a two-stage sample, you obtained a random sample of your population (the first stage sample), recording easy-to-obtain information that places subjects into two or more categories.  And then you  oversampled or undersampled these categories to obtain the `N` people whose values of `e`, `t`, `r`, and `category` you have recorded. `N_first_stage` counts the number of people from the first stage sample that fell in each category. If your categories were A and B, and in the first stage `472` fell in category A and `528` fell in category B, then you would use `N_first_stage` to be the named vector `c(A = 472, B = 528)`. Each name in `N_first_stage` must have at least one representative in `category`.

## `N_target` or `target_category`

If your cohort data do not match your target population, and you have a sample from your target population containing easy-to-obtain information that places subjects into releveant categories, `rmap` can perform a weighted analysis.
`N_target` counts the number of people from the target sample that falls in each category. If your categories were A and B, and in the first stage `472` fell in category A and `528` fell in category B, then you would use `N_target` to be the named vector `c(A = 472, B = 528)`. Each  name in `N_target` must have at least one representative in `category`. 

For your convenience, if you have a sample from the target population with the covariate category for each person in the target population, let `rmap` do the counting and supply you can supply this vector `target_category` to rmap instead of `N_target`.

[TOP](#top)

# `rmap` inputs

`rmap` must be called with the following arguments

## `e`, `t`, `r` 

These were described in the section "Data preparation".  If your cohort contains `N` subjects, then each of these is a vector of length `N`, and the `n`-th element pertains to the `n`-th subject.

## `t_star`

This positive number is the right end point of the time period of interest.  The risk model that you are evaluating expresses the risk of the outcome within the time period `[0, t_star]` and before a prespecified competing risk.

## `design`

Use this input to describe your study design and give `rmap` the necessary information to perform analyses based on your study design.  

If your design was a random sample, use `design = "random_sample".  

If your design was a two-stage sample, use `design = list(category = category, N_first_stage = N_first_stage)`

If your design was biased producing a cohort sample whose relevant categories do not proportionately match those of your target population, and you have a target sample with categories `target_category`, recording the covariate category of each person in the target sample, or `N_target`, counting the number of people in the target sample falling in each category, use `design = list(category = category, target_category = target_category)` or
`design = list(category = category, N_target = N_target)`.

## `risk_group`

`rmap` offers grouped and ungrouped analyses.  In a grouped analysis, you specify that the assigned risk be broken down into risk groups.  The number of such risk groups we say is `K`

If you would like `rmap` to break down your sample into `K` groups, for example `K = 4`, so the risks are broken down into quartiles, you can specify `risk_group = list(K = 4)`.  

If you would like to specify cut points to cut up the assigned risks, say all subjects having assigned risk `r` less than `0.30` in one risk group, greater than or equal `0.30` and less than `0.70` in the second risk group, and greater than or equal `0.70` in the third, you can specify `risk_group = list(cutoffs = (0, 0.30, 0.70, 1))`.

If you have broken down your risk groups manually and have a vector `k`, the `n`-th element equalling an integer in  `1, 2, ..., K`, indicating which risk group for the `n`-th person, you can specify `risk_group = list(k = k)`.

The above three methods show how to specify a grouped analysis.  For an ungrouped analysis, `rmap` does not perform formal tests or inference, but provides a summary plot, an individual or ungrouped attribute diagram providing an estimate of risk at each observed assigned risk using an epsilon kernel neighborhood.  To direct `rmap` to perform an ungrouped analysis, with `epsilon = N^(-1/3)` (theory suggests that the neighborhoods falling as `N^(-1/3)` have good asymptotic properties), use `risk_group = list(epsilon = epsilon)`.

## `r_summary`

`r_summary` allows you to choose how you would like to summarize the assigned risks in each risk group.  
You can specify `r_summary = "mean"` or `r_summary = "median"` with the obvious effect.  Or if your risk groups were specified using `risk_group = list(cutoffs = cutoffs)`, with `cutoffs = c(0, 0.30, 0.70, 1)`, for example, you can specify `r_summary = "midpoint"` to use the midpoint of each interval defined by your `cutoffs`, in this example, `0.15, 0.50, 0.85` being the summary values of the three risk groups.

## `N_bootstraps`

This nonnegative integer specifies the number of bootstraps.  If `N_bootstraps = 0`, no bootstraps are performed. For random samples and two-stage samples, grouped goodness-of-fit tests and concordance estimates can be gotten, but for inferences on concordance as well inferences on all quantities when the design is a weighted sample, bootstraps are required.


## `confidence_level`

A positive number less than `1`, defaulted to `0.95`.  If you do not specify `confidence_level`, rmap will use `0.95`.

## `N_cores`

This postive number specifies the number of cores to use.  It defaults to `1`, but if you would like parallel processing on the bootstrap calculations, you can specify the number of cores your system can alot to `rmap`.

## `verbose`

If you would like `rmap` to output extra information to show the progress of the bootstraps, you may specify `verbose = TRUE`.  This variable defaults to `FALSE`.


# Explaining `rmap` output

## Grouped `rmap` output 

Grouped `rmap` output is broken down into two objects: `numerical_summaries` and `plots`.  

`numerical_summaries` consist of the following

1. `concordance` contains the concordance `estimate` as well as the `lower` and `upper` bounds of a 95 percent bootstrap confidence interval (or a confidence interval with a different confidence-level if you specified it with the input `confidence_level`)

2. `gof_asymptotic` contains the goodness of fit `statistic` as well as its `p_value` for testing if the grouped assigned risks fit the observed cohort data.  The variance used to calculate the `statistic` is gotten by asymptotic theory.

3. `gof_bootstrap` is similar to `gof_asymptotic` but variances are gotten by the bootstrap.

4. `grouped_estimates` is a data.frame containing 
`gamma_hat` which estimates the proportion of subjects in each risk group,
`r` which summarizes the assigned risk in each risk group,
and `pi_hat` which estimates the probability of getting the outcome before `t_star` and before the competing risk.

5. `grouped_asymptotic_sds` is a data.frame containing `sd` the square root of the variance of `pi_hat` for each risk group, the `lower` and `upper` bounds of the 95 percent confidence interval, and `in_ci` indicating whether or not the confidence interval contains `r`.   The estimated variance and confidence intervals are calculated using asymptotic theory.  This is available only for random samples and two-stage samples.

4. `grouped_bootstrap_sds` is similar to `grouped_asymptotic_sds`, but the variance and confidence intervals are calculated using the bootstrap.  This is available only if you specify `N_bootstraps` to be a nonzero number.

`plots` contain

1. `df_for_roc_plot` is a data.frame that you can use to contstruct custom ROC plots.

2. `roc_plot` contains a ROC plot with `one_minus_specificity` on the x-axis and `sensitivity` on the y-axis.

3. `risk_plot` contains a grouped attribute diagram with the column `grouped_estimates$r` plotted on the x-axis and `grouped_estimates$pi_hat` together with `grouped_asymptotic_sds$lower` and `grouped_asymptotic_sds$upper` (if they are available or if they are not aviable use `grouped_bootstrap_sds$lower` and `grouped_bootstrap_sds$upper`) plotted on the y-axis.

## Ungrouped `rmap` output  

Ungrouped `rmap` output contains just `plots` which consists of

1. `df_for_risk_plot` is a data.frame that you can use to construct custom ungrouped attribute diagrams.

2. `risk_plot` contains an ungrouped attribute diagram with unique values of the input `r` plotted on the x-axis and epsilon kernel nearest neighbor estiamte of outcome probability on the y-axis.

# A random sample example

If you have a random sample, and you are happy enough using assigned risk quantiles to separate your assign risks into risk groups, you can use the wrapper functions `rmap_random_sample`, if you are not interested in an ungrouped analysis

```{r fig.height = 3, fig.width = 7}
library(rmap)
xxx = read.csv(file = "random_sample_example.csv", stringsAsFactors = FALSE)
e = xxx$e
t = xxx$t
r = xxx$r
t_star = 10
rmap_1 = rmap_random_sample(e, t, r, t_star)
grid.arrange(rmap_1$roc_plot, rmap_1$grouped_risk_plot, 
             ncol = 2, 
             top = "A very simple example of rmap in action")
```

or `rmap_random_sample_ungrouped_too` if you wish to include an ungrouped attribute diagram.

```{r eval = FALSE, fig.height = 5, fig.width = 7}
library(rmap)
xxx = read.csv(file = "random_sample_example.csv", stringsAsFactors = FALSE)
e = xxx$e
t = xxx$t
r = xxx$r
t_star = 10
set.seed(1)
rmap_2 = rmap_random_sample_ungrouped_too(e, t, r, t_star)
the_message = paste("rmap_random_sample_ungrouped_too plots", sep = "\n")
grid.arrange(textGrob(the_message),  rmap_2$grouped_risk_plot, 
             rmap_2$roc_plot, rmap_2$ungrouped_risk_plot,
             ncol = 2)
```

Each of the functions `rmap_random_sample` and `rmap_random_sample_ungrouped_too` is a wrapper function.  You can see what is inside the definition of a function just by sending to R the name of the function, without trailing parentheses or inputs.  (I won't actually evaluate the next command here because even the simpler one is quite long

```{r eval = FALSE}
rmap_random_sample
```

# A weighted cohort example

```{r}
library(rmap)
xxx = read.csv("weighted_example_cohort_sample.csv", stringsAsFactors = FALSE)
head(xxx)
e = xxx$e
t = xxx$t
r = xxx$r
t_star = 10
target_sample = read.csv("weighted_example_target_sample.csv", stringsAsFactors = FALSE)
head(target_sample)
target_category = target_sample$category
category = xxx$category
design = list(target_category = target_category, category = category)
cutoffs = c(0, 0.20, 1)
risk_group = list(cutoffs = cutoffs)
r_summary = "mean"
N_bootstraps = 100
confidence_level = 0.95
N_cores = 1
verbose = FALSE
set.seed(1)
grouped = rmap(e, t, r, t_star, design, risk_group, r_summary, 
              N_bootstraps, confidence_level, N_cores, verbose)

numerical_summaries = grouped$numerical_summaries
plots = rmap_3$plots
grid.arrange(plots$roc_plot, plots$risk_plot, ncol = 2, 
             top = "rmap_grouped on a weighted sample")
epsilon = nrow(xxx)^(-1/3)
risk_group = list(epsilon = epsilon)
set.seed(6)
rmap_6 = rmap(e, t, r, t_star, design, risk_group, r_summary, 
              N_bootstraps, confidence_level, N_cores, verbose)
plots = rmap_6$plots
```


```{r}

```

